var fs = Npm.require('fs');
var path = Npm.require('path');
var _ = Npm.require('underscore');
var Future = Npm.require('fibers/future');
var ts = Npm.require('ts-compiler');

var stripExportedVars = function(source, exports) {
	if (!exports || _.isEmpty(exports))
		return source;
	var lines = source.split("\n");

	// We make the following assumptions, based on the output of CoffeeScript
	// 1.6.3.
	//   - The var declaration in question is not indented and is the first such
	//     var declaration.  (CoffeeScript only produces one var line at each
	//     scope and there's only one top-level scope.)  All relevant variables
	//     are actually on this line.
	//   - The user hasn't used a ###-comment containing a line that looks like
	//     a var line, to produce something like
	//        /* bla
	//        var foo;
	//        */
	//     before an actual var line.  (ie, we do NOT attempt to figure out if
	//     we're inside a /**/ comment, which is produced by ### comments.)
	//   - The var in question is not assigned to in the declaration, nor are any
	//     other vars on this line. (CoffeeScript does produce some assignments
	//     but only for internal helpers generated by CoffeeScript, and they end
	//     up on subsequent lines.)
	// XXX relax these assumptions by doing actual JS parsing (eg with jsparse).
	//     I'd do this now, but there's no easy way to "unparse" a jsparse AST.
	//     Or alternatively, hack the compiler to allow us to specify unbound
	//     symbols directly.

	for (var i = 0 ; i < lines.length ; i++) {
		var line = lines[i];
		var match = /^var (.+)([,;])$/.exec(line);
		if (!match)
			continue;

		// If there's an assignment on this line, we assume that there are ONLY
		// assignments and that the var we are looking for is not declared. (Part
		// of our strong assumption about the layout of this code.)
		if (match[1].indexOf('=') !== -1)
			continue;

		// We want to replace the line with something no shorter, so that all
		// records in the source map continue to point at valid
		// characters.
		var replaceLine = function(x) {
			if (x.length >= lines[i].length) {
				lines[i] = x;
			} else {
				lines[i] = x + new Array(1 + (lines[i].length - x.length)).join(' ');
			}
		};

		var vars = match[1].split(', ');
		vars = _.difference(vars, exports);
		if (!_.isEmpty(vars)) {
			replaceLine("var " + vars.join(', ') + match[2]);
		} else {
			// We got rid of all the vars on this line. Drop the whole line if this
			// didn't continue to the next line, otherwise keep just the 'var '.
			if (match[2] === ';')
				replaceLine('');
			else
				replaceLine('var');
		}
		break;
	}

	return lines.join('\n');
};

// Used to check the filename extension
var endsWith = function(str, ends) {
	if (str == null) return false;
	return str.length >= ends.length && str.slice(str.length - ends.length) === ends;
};

function compile(compileStep) {

	var future = new Future;

	var jsVersion = "ES5";
	if (compileStep.archMatches("browser"))
		jsVersion = "ES3";

	var filename = compileStep.inputPath;
	console.log("Compiling "+jsVersion+' '+compileStep._fullInputPath);

	ts.compile(
		[compileStep._fullInputPath],

		{ 'skipWrite': true, 'target': jsVersion, 'removeComments': true },
		function(err, results) {

			if(err) {
				console.log('\x1b[36m%s\x1b[0m', err);
			//	console.log("ERROR:" + err);
				return;
				//future.return(err);
			}
			else {
				if (results) {

					var generatedItem = results[0];
					var src;
					// Some ts files (especially .d.ts files) may compile to an empty string
					if (generatedItem)
						src = generatedItem.text;

					if (src.length > 0) {
						//console.log(src);
						compileStep.addJavaScript({
							path: filename + ".js",
							sourcePath: filename,
							data: src
						});
					}

					return future.return(true);
				}
				else return future.return(false);
			}
		}
	);

	return future;

}

var handler = function(compileStep) {

	var filename = compileStep.inputPath;

	if (!endsWith(filename, ".d.ts")) {
		var result = compile(compileStep).wait();
		if (result !== true)
			throw new Error(result);
	}
};

Plugin.registerSourceHandler("ts", handler);
